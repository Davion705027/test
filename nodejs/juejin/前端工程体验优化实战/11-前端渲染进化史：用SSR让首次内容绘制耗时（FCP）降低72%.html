<header>
        <style>
            .markdown-body{
                width: 80%;
                margin: auto;
            }
            .code-block-extension-header{
                display: none;
            }
        </style>
    </header><div class="markdown-body"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>如何渲染页面决定了前端应用的用户体验，要想从根本上优化前端页面的加载表现，尤其是首次内容绘制（FCP）指标，改变前端应用的渲染方式是最强的杀手锏。</p>
<h2 data-id="heading-0">1. 前端应用渲染简史</h2>
<p>让我们先回顾一下，前端应用渲染方式发展的历程，每个阶段的痛点及其解决方案。</p>
<h3 data-id="heading-1"><strong>早期服务端渲染：</strong></h3>
<p>在2000年前后，HTTP协议和HTML诞生之初，还没有前端的概念，网页内容朴素，交互极为简单，HTML代码大都是用PHP等脚本语言在服务端以字符串形式拼接产生，并返回给用户客户端浏览器，直接渲染出完整页面。</p>
<h3 data-id="heading-2"><strong>客户端渲染：</strong></h3>
<p>在2005年前后，随着JS语言<code>DOM</code>API的逐渐完善和前端<code>AJAX</code>异步数据交换的广泛应用，早期服务端渲染已无法满足网页交互日益复杂的需求，网页的开发复杂度越来越高、维护所需的专业性也越来越强，逐渐形成了独立的前端应用。</p>
<p>渲染方式也过渡到了<strong>客户端渲染（Client Side Render，CSR）</strong> &nbsp;，即主要由JS控制在浏览器中生成HTML标签和CSS样式，供用户浏览，并添加事件监听等逻辑，与用户交互。</p>
<p>这一阶段真正区分了前端与后端，社区中也陆续诞生了<code>jQuery</code>,&nbsp;<code>Angular.js</code>,&nbsp;<code>React.js</code>,&nbsp;<code>Vue.js</code>等一大批客户端渲染框架。</p>
<h3 data-id="heading-3"><strong>Node.js服务端渲染：</strong></h3>
<p>但是客户端渲染的前端应用也有天然的痛点：</p>
<ul>
<li><strong>用户体验有明显短板</strong>：因为浏览器对JS的加载和解析执行需要一定时间，导致客户端渲染的前端应用都有初始化时页面白屏的问题。</li>
<li><strong>搜索引擎优化（SEO）不佳</strong>：因为搜索引擎爬虫一般不支持执行JS，但CSR又必须执行JS后才能渲染出内容，所以无法适应爬虫的索引内容需求，导致CSR的前端应用在搜索引擎中排名靠后，流量减少。</li>
<li><strong>开发体验不佳</strong>：前后端分离也带来了一些不便之处，例如：<code>index.html</code>模板维护在后端项目中，不便于前端工程师修改调试，造成了前端能力的缺陷。</li>
</ul>
<p>所以，在2009年前后随着Node.js的诞生，伴随其独特的事件驱动非阻塞的特性，也产生了一批基于字符串拼接的<strong>服务端渲染（Server Side Render，SSR）</strong> &nbsp;前端应用，致力于解决上述CSR的痛点。</p>
<p>2015年前后，<code>React.js</code>和<code>Vue.js</code>框架对服务端渲染增加了专门API支持，Node.js服务端渲染进而成为了近年来前端应用的主流架构之一，并且诞生了<code>Next.js</code>,&nbsp;<code>Nuxt.js</code>，<code>Gatsby</code>等一批专门的服务端渲染框架。</p>
<h2 data-id="heading-4">2. 服务端渲染 SSR 原理及同构架构简介</h2>
<p>目前流行的SSR架构核心原理大都基于前端框架的2项能力实现，分别是：</p>
<h3 data-id="heading-5">1. Node.js服务端<code>renderToString(element: ReactElement)</code>：</h3>
<p>这一能力能支持将基于前端框架编写的组件源代码渲染为HTML字符串，以便在Node.js端作为HTTP响应内容返回给用户，这个过程一般称之为渲染富文本字符串（<code>renderToString</code>）</p>
<p>例如<code>React.js</code>框架生态中<code>react-dom/server</code>库的<code>renderToString()</code>API：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">js</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-js code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">import</span> { renderToString } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/server'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">const</span> html = <span class="hljs-title function_">renderToString</span>(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);  <span class="hljs-comment">// 返回 HTML 富文本字符串</span></span>
</code></pre>
<p><code>Vue.js</code>框架生态中<code>vue/server-renderer</code>库的<code>renderToString()</code>API：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">js</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-js code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">import</span> { createSSRApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span></span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-keyword">import</span> { renderToString } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue/server-renderer'</span></span>
<span class="code-block-extension-codeLine" data-line-num="3"></span>
<span class="code-block-extension-codeLine" data-line-num="4"><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createSSRApp</span>({  </span>
<span class="code-block-extension-codeLine" data-line-num="5">  <span class="hljs-attr">data</span>: <span class="hljs-function">() =&gt;</span> ({ <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> }),  </span>
<span class="code-block-extension-codeLine" data-line-num="6">  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;button @click="count++"&gt;{{ count }}&lt;/button&gt;`</span>,</span>
<span class="code-block-extension-codeLine" data-line-num="7">})</span>
<span class="code-block-extension-codeLine" data-line-num="8"> </span>
<span class="code-block-extension-codeLine" data-line-num="9"><span class="hljs-title function_">renderToString</span>(app)</span>
<span class="code-block-extension-codeLine" data-line-num="10">    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">html</span>) =&gt;</span> {  </span>
<span class="code-block-extension-codeLine" data-line-num="11">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(html) <span class="hljs-comment">// HTML 富文本字符串</span></span>
<span class="code-block-extension-codeLine" data-line-num="12">    })</span>
</code></pre>
<p>有了<code>renderToString</code>这项能力，我们就能把源代码转化为用户可以浏览的HTML内容，在服务端实现渲染页面的能力。</p>
<h3 data-id="heading-6">2. 浏览器客户端<code>hydrate(element: ReactElement, container: HTMLElement)</code>：</h3>
<p>将Node.js端响应返回的HTML富文本在浏览器端，用JS遍历检查后，赋予事件监听等交互逻辑,这个过程一般称之为活化（<code>hydrate</code>）</p>
<p>例如<code>React.js</code>框架的<code>hydrate()</code>API：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">js</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-js code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">import</span> { hydrate } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-title function_">hydrate</span>(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'root'</span>));</span>
<span class="code-block-extension-codeLine" data-line-num="4"><span class="hljs-comment">// 调用后，即可将 &lt;App /&gt; 组件的交互逻辑赋予 #root DOM 元素，让它“活”起来</span></span>
</code></pre>
<blockquote>
<p>注：React@18 版本后，活化使用的API变成了<code>hydrateRoot()</code></p>
</blockquote>
<p>有了活化<code>hydrate</code>能力，我们就能为<code>renderToString</code>返回的<strong>无交互逻辑</strong>HTML富文本，加上点击、输入、滚动等各类交互。</p>
<p>这种运行同一套源码，在客户端和服务端分别渲染出HTML的架构，业界称之为<strong>同构</strong>架构（Isomorphic）。</p>
<p>将CSR前端项目改为同构架构SSR架构，并没有想象中那么复杂，只需要200行左右的代码改造，就可以实现。</p>
<p>下面我们将继续使用<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FJuniorTour%2Ffe-optimization-demo" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/JuniorTour/fe-optimization-demo" ref="nofollow noopener noreferrer">fe-optimization-demo</a>示例项目，演示这一改造的流程。</p>
<h2 data-id="heading-7">3. 示例：200行代码将CSR前端项目重构为SSR</h2>
<h3 data-id="heading-8">1. 新建Node.js服务器应用</h3>
<p>首先，我们需要搭建一个Node.js Server用于：</p>
<ul>
<li>接收用户请求，获取用户访问的URL等上下文数据，这次我们使用Express框架的<code>.get('*', handler)</code>API，接收所有路由的请求；</li>
<li>调用<code>renderToString()</code>，获取源码渲染后的HTML字符串；</li>
<li>把渲染后的HTML作为HTTP响应返回给用户；</li>
</ul>
<blockquote>
<p>完整代码示例请参考MR《CSR to SSR》：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FJuniorTour%2Ffe-optimization-demo%2Fpull%2F4" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/JuniorTour/fe-optimization-demo/pull/4" ref="nofollow noopener noreferrer">github.com/JuniorTour/…</a></p>
</blockquote>
<p>核心代码逻辑请看如下：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">js</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-js code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-comment">// server\index.tsx</span></span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-keyword">import</span> { renderToString } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/server'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="4"></span>
<span class="code-block-extension-codeLine" data-line-num="5"><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();</span>
<span class="code-block-extension-codeLine" data-line-num="6"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = <span class="hljs-number">3000</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="7"></span>
<span class="code-block-extension-codeLine" data-line-num="8">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'*'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="9">  <span class="hljs-keyword">const</span> reqURL = req.<span class="hljs-property">url</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="10">  <span class="hljs-keyword">const</span> markup = <span class="hljs-title function_">renderToString</span>(</span>
<span class="code-block-extension-codeLine" data-line-num="11">    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"hello-ssr"</span>&gt;</span>Hello SSR! 你请求的URL是{reqURL}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,</span>
<span class="code-block-extension-codeLine" data-line-num="12">  );</span>
<span class="code-block-extension-codeLine" data-line-num="13">  <span class="hljs-comment">// eslint-disable-next-line no-console</span></span>
<span class="code-block-extension-codeLine" data-line-num="14">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`markup=<span class="hljs-subst">${markup.substring(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)}</span>`</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="15">  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`</span></span>
<span class="code-block-extension-codeLine" data-line-num="16">&lt;!DOCTYPE html&gt;</span>
<span class="code-block-extension-codeLine" data-line-num="17">&lt;html&gt;</span>
<span class="code-block-extension-codeLine" data-line-num="18">  &lt;head&gt;</span>
<span class="code-block-extension-codeLine" data-line-num="19">    &lt;title&gt;SSR Example&lt;/title&gt;</span>
<span class="code-block-extension-codeLine" data-line-num="20">  &lt;/head&gt;</span>
<span class="code-block-extension-codeLine" data-line-num="21">  &lt;body&gt;</span>
<span class="code-block-extension-codeLine" data-line-num="22">    &lt;div id="root"&gt;<span class="hljs-subst">${markup}</span>&lt;/div&gt;</span>
<span class="code-block-extension-codeLine" data-line-num="23">    &lt;script src="/bundle.js"&gt;&lt;/script&gt;</span>
<span class="code-block-extension-codeLine" data-line-num="24">  &lt;/body&gt;</span>
<span class="code-block-extension-codeLine" data-line-num="25">&lt;/html&gt;</span>
<span class="code-block-extension-codeLine" data-line-num="26">  `);</span>
<span class="code-block-extension-codeLine" data-line-num="27">});</span>
<span class="code-block-extension-codeLine" data-line-num="28"></span>
<span class="code-block-extension-codeLine" data-line-num="29">app.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>, <span class="hljs-function">() =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="30">  <span class="hljs-comment">// eslint-disable-next-line no-console</span></span>
<span class="code-block-extension-codeLine" data-line-num="31">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`SSR Server is listening on http://localhost:<span class="hljs-subst">${PORT}</span>`</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="32">});</span>
</code></pre>
<p>这段代码中，我们尚未把项目的组件源码（<code>&lt;APP /&gt;</code>）作为参数传给<code>renderToString</code>，而是用了极其简单的组件<code>&lt;div&gt;Hello SSR...&lt;div/&gt;</code>，从而简化逻辑，便于理解。</p>
<p>但是这段代码用的是TSX语法，保存成了<code>.tsx</code>文件，Node.js无法直接运行，所以我们需要用Webpack，把这个文件编译成JS语法代码。</p>
<h3 data-id="heading-9">2. 配置服务器端Webpack打包编译</h3>
<p>这一步的目标是：</p>
<ul>
<li>将TSX语法的<code>.tsx</code>源文件编译为<code>.js</code>文件；</li>
<li>用 Node.js 运行时直接启动服务器应用；</li>
</ul>
<p>我们的示例项目中已经有配置好了<code>babel-loader</code>等打包编译前端应用的基础配置文件：<code>common.config.js</code>，所以为服务器端新增Webpack的配置很简单，只需要基于这份基础配置，写13行代码：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">js</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-js code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-comment">// webpack\server.config.js</span></span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">const</span> { merge } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-merge'</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="4"><span class="hljs-keyword">const</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./common.config'</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="5"></span>
<span class="code-block-extension-codeLine" data-line-num="6"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">merge</span>(common, {</span>
<span class="code-block-extension-codeLine" data-line-num="7">  <span class="hljs-attr">mode</span>: <span class="hljs-string">'development'</span>, <span class="hljs-comment">// 便于开发调试，排查报错堆栈</span></span>
<span class="code-block-extension-codeLine" data-line-num="8">  <span class="hljs-attr">entry</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'../server/index.tsx'</span>),</span>
<span class="code-block-extension-codeLine" data-line-num="9">  <span class="hljs-attr">output</span>: {</span>
<span class="code-block-extension-codeLine" data-line-num="10">    <span class="hljs-attr">filename</span>: <span class="hljs-string">'server.js'</span>,</span>
<span class="code-block-extension-codeLine" data-line-num="11">    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'../dist'</span>),</span>
<span class="code-block-extension-codeLine" data-line-num="12">  },</span>
<span class="code-block-extension-codeLine" data-line-num="13">  <span class="hljs-attr">target</span>: <span class="hljs-string">'node'</span>, <span class="hljs-comment">// 目标环境为 Node.js</span></span>
<span class="code-block-extension-codeLine" data-line-num="14">});</span>
</code></pre>
<p>新建的这份配置，主要改动在于指定入口文件<code>entry</code>和产物文件<code>output</code>，并将打包构建目标环境为设置为Node.js（<code>target: 'node'</code>），专门用于打包编译Node.js服务器应用源码，生成Node.js运行时支持的JS语法代码。</p>
<p>下面，我们只需要在<code>package.json</code>中配置如下3个脚本命令，就可以通过执行<code>npm run build-server</code>打包编译，再用<code>npm run start-server</code>运行Node.js服务器应用：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">json</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-json code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></span>
<span class="code-block-extension-codeLine" data-line-num="2">     <span class="hljs-comment">// ...</span></span>
<span class="code-block-extension-codeLine" data-line-num="3">    <span class="hljs-attr">"build-server"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cross-env NODE_ENV=production webpack --config ./webpack/server.config.js"</span><span class="hljs-punctuation">,</span></span>
<span class="code-block-extension-codeLine" data-line-num="4">    <span class="hljs-attr">"start-debug-server"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node --inspect-brk ./dist/server.js"</span><span class="hljs-punctuation">,</span></span>
<span class="code-block-extension-codeLine" data-line-num="5">    <span class="hljs-attr">"start-server"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node ./dist/server.js"</span><span class="hljs-punctuation">,</span></span>
<span class="code-block-extension-codeLine" data-line-num="6">  <span class="hljs-punctuation">}</span></span>
</code></pre>
<p><code>start-debug-server</code>用于调试服务器应用。执行后，从浏览器的Devtool中就可以方便地调试Node.js应用，入口位置如下图：&nbsp;</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0fdc3d414ca429997e266adb237ee09~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp#?w=542&amp;h=658&amp;s=37896&amp;e=webp&amp;b=1f1f1f" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>服务器应用运行后，访问<a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A3000%2Fhome%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://localhost:3000/home/" ref="nofollow noopener noreferrer">http://localhost:3000/home/</a>&nbsp;，就可以从Devtool的Network中看到，SSR服务器直接响应了我们指定的<code>div.hello-ssr</code>元素。</p>
<p>而CSR应用，响应的HTML中只会有最外层的<code>&lt;div id="root"&gt;&lt;/div&gt;</code>这一点代码。</p>
<p>如下图所示，在文档响应中就包含渲染后的完整HTML DOM，这也是SSR和CSR应用的核心区别。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54e246fcbe1b42c5983f50e4cdc404c4~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp#?w=1920&amp;h=934&amp;s=57892&amp;e=webp&amp;b=2c2c2c" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>但是目前并没有渲染我们写的前端组件源代码<code>&lt;APP /&gt;</code>，所以还需要把<code>renderToString(element: ReactElement)</code>的参数，改成我们前端组件。</p>
<h3 data-id="heading-10">3. 增加服务端渲染中间件<code>serverRenderer(req, res)</code></h3>
<p>我们新建一个<code>server\renderer.tsx</code>文件，用来保存服务端渲染前端组件源代码的逻辑，并封装成一个<code>express</code>框架的中间件：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">js</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-js code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-keyword">import</span> { renderToString } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/server'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">StaticRouterContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="4"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">StaticRouter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="5"><span class="hljs-keyword">import</span> { readFileSync } <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="6"><span class="hljs-keyword">import</span> { resolve } <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="7"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">App</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/app/ui/app/app'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="8"><span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">DIST</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../webpack/constants'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="9"></span>
<span class="code-block-extension-codeLine" data-line-num="10"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getIndexHTMLTemplate</span>(<span class="hljs-params"></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="11">  <span class="hljs-keyword">return</span> <span class="hljs-title function_">readFileSync</span>(<span class="hljs-title function_">resolve</span>(<span class="hljs-variable constant_">DIST</span>, <span class="hljs-string">'index.html'</span>), {</span>
<span class="code-block-extension-codeLine" data-line-num="12">    <span class="hljs-attr">encoding</span>: <span class="hljs-string">'utf-8'</span>,</span>
<span class="code-block-extension-codeLine" data-line-num="13">  });</span>
<span class="code-block-extension-codeLine" data-line-num="14">}</span>
<span class="code-block-extension-codeLine" data-line-num="15"></span>
<span class="code-block-extension-codeLine" data-line-num="16"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">serverRenderer</span>(<span class="hljs-params">req, res</span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="17">  <span class="hljs-keyword">const</span> <span class="hljs-attr">context</span>: <span class="hljs-title class_">StaticRouterContext</span> = {};</span>
<span class="code-block-extension-codeLine" data-line-num="18"></span>
<span class="code-block-extension-codeLine" data-line-num="19">  <span class="hljs-keyword">const</span> markup = <span class="hljs-title function_">renderToString</span>(</span>
<span class="code-block-extension-codeLine" data-line-num="20">    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">StaticRouter</span> <span class="hljs-attr">context</span>=<span class="hljs-string">{context}</span> <span class="hljs-attr">location</span>=<span class="hljs-string">{req.url}</span>&gt;</span></span></span>
<span class="code-block-extension-codeLine" data-line-num="21">      <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>
<span class="code-block-extension-codeLine" data-line-num="22">    <span class="hljs-tag">&lt;/<span class="hljs-name">StaticRouter</span>&gt;</span>,</span>
<span class="code-block-extension-codeLine" data-line-num="23">  );</span>
<span class="code-block-extension-codeLine" data-line-num="24"></span>
<span class="code-block-extension-codeLine" data-line-num="25">  <span class="hljs-comment">// eslint-disable-next-line no-console</span></span>
<span class="code-block-extension-codeLine" data-line-num="26">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`markup=<span class="hljs-subst">${markup.substring(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)}</span>`</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="27"></span>
<span class="code-block-extension-codeLine" data-line-num="28">  <span class="hljs-keyword">if</span> (context.<span class="hljs-property">url</span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="29">    <span class="hljs-comment">// eslint-disable-next-line no-console</span></span>
<span class="code-block-extension-codeLine" data-line-num="30">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`context?.url=<span class="hljs-subst">${context?.url}</span>`</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="31">    <span class="hljs-comment">// 某处渲染了 `&lt;Redirect /&gt;` 组件</span></span>
<span class="code-block-extension-codeLine" data-line-num="32">    res.<span class="hljs-title function_">redirect</span>(<span class="hljs-number">301</span>, context.<span class="hljs-property">url</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="33">  } <span class="hljs-keyword">else</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="34">    res.<span class="hljs-title function_">send</span>(</span>
<span class="code-block-extension-codeLine" data-line-num="35">      <span class="hljs-title function_">getIndexHTMLTemplate</span>().<span class="hljs-title function_">replace</span>(</span>
<span class="code-block-extension-codeLine" data-line-num="36">        <span class="hljs-string">'&lt;div id="root"&gt;&lt;/div&gt;'</span>,</span>
<span class="code-block-extension-codeLine" data-line-num="37">        <span class="hljs-string">`&lt;div id="root"&gt;<span class="hljs-subst">${markup}</span>&lt;/div&gt;`</span>,</span>
<span class="code-block-extension-codeLine" data-line-num="38">      ),</span>
<span class="code-block-extension-codeLine" data-line-num="39">    );</span>
<span class="code-block-extension-codeLine" data-line-num="40">  }</span>
<span class="code-block-extension-codeLine" data-line-num="41">}</span>
</code></pre>
<p>这段代码中，我们把根组件<code>&lt;App /&gt;</code>作为<code>renderToString(element: ReactElement)</code>的参数，从而让服务端得到用户渲染后的HTML富文本字符串，响应给用户。</p>
<p>并且，为了避免<code>react-router</code>的部分API依赖浏览器环境的问题，我们在服务端使用了不依赖浏览器的<code>&lt;StaticRouter&gt;</code>组件。</p>
<p>另外，对于前端路由触发重定向的情况，我们也通过检测<code>context.url</code>和<code>res.redirect(301, context.url)</code>进行了兼容处理。</p>
<p>最后，如果没有重定向，那么就可以直接调用<code>res.send()</code>，给用户响应服务端渲染出的HTML字符串了。</p>
<p>对于响应的HTML字符串，我们声明了<code>getIndexHTMLTemplate()</code>来提取客户端打包编译时<code>HtmlWebpackPlugin</code>生成的<code>index.html</code>作为模板文件，只替换<code>&lt;div id="root"&gt;</code>中的内容即可。</p>























<table><thead><tr><th><code>react-router</code>&nbsp;API</th><th>功能描述</th><th>特点</th><th>用法示例</th></tr></thead><tbody><tr><td><a href="https://link.juejin.cn/?target=https%3A%2F%2Fv5.reactrouter.com%2Fweb%2Fapi%2FBrowserRouter" title="https://link.juejin.cn/?target=https%3A%2F%2Fv5.reactrouter.com%2Fweb%2Fapi%2FBrowserRouter" target="_blank">BrowserRouter</a></td><td>在<strong>浏览器</strong>平台创建前端路由上下文。</td><td><strong>依赖</strong>&nbsp;HTML5 history API运行，只能在浏览器平台运行。</td><td><code>ReactDOM.hydrate( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, document.getElementById('root'), );</code></td></tr><tr><td><a href="https://link.juejin.cn/?target=https%3A%2F%2Fv5.reactrouter.com%2Fweb%2Fapi%2FStaticRouter" title="https://link.juejin.cn/?target=https%3A%2F%2Fv5.reactrouter.com%2Fweb%2Fapi%2FStaticRouter" target="_blank">StaticRouter</a></td><td>在<strong>任意</strong>平台创建前端路由上下文。</td><td><strong>不依赖</strong>任何浏览器平台API，可以在Node.js平台运行。</td><td><code>const html = ReactDOMServer.renderToString( &lt;StaticRouter location={req.url} context={context}&gt; &lt;App /&gt; &lt;/StaticRouter&gt; );</code></td></tr></tbody></table>
<p>最后，别忘了把<code>serverRenderer</code>函数设置为服务端路由的处理函数：<code>app.get('*', serverRenderer);</code>。</p>
<p>再次执行<code>npm run build-server</code>打包编译，我们会遇到重构的难点之一：解决各类打包运行问题。</p>
<h3 data-id="heading-11">4. 解决打包编译、运行时问题</h3>
<p>首先，我们会在打包编译时遇到CSS编译报错：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">js</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-js code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-variable constant_">ERROR</span> <span class="hljs-keyword">in</span> ./shared/ui/spinner/index.<span class="hljs-property">module</span>.<span class="hljs-property">css</span> <span class="hljs-number">1</span>:<span class="hljs-number">0</span></span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-title class_">Module</span> parse <span class="hljs-attr">failed</span>: <span class="hljs-title class_">Unexpected</span> character <span class="hljs-string">'@'</span> (<span class="hljs-number">1</span>:<span class="hljs-number">0</span>)</span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-title class_">You</span> may need an appropriate loader to handle <span class="hljs-variable language_">this</span> file type, currently no loaders are configured to process <span class="hljs-variable language_">this</span> file. <span class="hljs-title class_">See</span> <span class="hljs-attr">https</span>:<span class="hljs-comment">//webpack.js.org/concepts#loaders</span></span>
<span class="code-block-extension-codeLine" data-line-num="4">&gt; @keyframes spinner-border {</span>
<span class="code-block-extension-codeLine" data-line-num="5">|   to {</span>
<span class="code-block-extension-codeLine" data-line-num="6">|     <span class="hljs-attr">transform</span>: <span class="hljs-title function_">rotate</span>(360deg);</span>
</code></pre>
<p>这是因为，我们的Webpack配置<code>server.config.js</code>没有处理CSS module的<code>loader</code>，将<code>webpack\production.config.js</code>中相关的<code>plugins.MiniCssExtractPlugin</code>、<code>module.rules.test: /.css$/</code>提取出来供<code>server.config.js</code>复用即可解决。</p>
<p>再次执行<code>npm run build-server</code>打包编译，就能成功了。</p>
<p>但是执行<code>npm run start-server</code>，还会再遇到一个报错：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">js</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-js code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-attr">webpack</span>:<span class="hljs-comment">///../node_modules/tiny-invariant/dist/tiny-invariant.esm.js?:16</span></span>
<span class="code-block-extension-codeLine" data-line-num="2">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(value);</span>
<span class="code-block-extension-codeLine" data-line-num="3">    ^</span>
<span class="code-block-extension-codeLine" data-line-num="4"></span>
<span class="code-block-extension-codeLine" data-line-num="5"><span class="hljs-title class_">Error</span>: <span class="hljs-title class_">Invariant</span> <span class="hljs-attr">failed</span>: <span class="hljs-title class_">Browser</span> history needs a <span class="hljs-variable constant_">DOM</span></span>
<span class="code-block-extension-codeLine" data-line-num="6">    at invariant (<span class="hljs-attr">webpack</span>:<span class="hljs-comment">///../node_modules/tiny-invariant/dist/tiny-invariant.esm.js?:16:11)</span></span>
<span class="code-block-extension-codeLine" data-line-num="7">    at createBrowserHistory (<span class="hljs-attr">webpack</span>:<span class="hljs-comment">///../node_modules/history/esm/history.js?:265:82)</span></span>
<span class="code-block-extension-codeLine" data-line-num="8">    at <span class="hljs-built_in">eval</span> (<span class="hljs-attr">webpack</span>:<span class="hljs-comment">///./shared/router/model/store.ts?:14:76)</span></span>
</code></pre>
<p>这个报错的原因，文案描述的很清楚，是因为源码中使用了<code>history</code>开源库的<code>createBrowserHistory</code>&nbsp;API，其需要基于浏览器环境的History API才能运行，但是Node.js环境没有这个API，所以运行时就报错了。</p>
<p>针对这种问题，各大开源库都有专门的Node.js 平台 API 可以替换，我们可以通过替换为不依赖浏览器环境的<code>createMemoryHistory</code>API来解决。</p>
<blockquote>
<p>注：对比路由库的2类API：</p>
</blockquote>




















<table><thead><tr><th><code>history</code>&nbsp;API</th><th>功能描述</th><th>URL 变化</th></tr></thead><tbody><tr><td><code>createBrowserHistory()</code></td><td>基于<strong>原生</strong>HTML5 history API，创建保存前端应用路由记录数据的对象。</td><td>创建的历史记录对象状态变化时URL<strong>会</strong>随之变化。</td></tr><tr><td><code>createMemoryHistory()</code></td><td>在<strong>内存</strong>中创建保存前端应用路由记录数据的对象。</td><td>创建的历史记录对象状态变化时URL<strong>不会</strong>随之变化。</td></tr></tbody></table>
<p>但是<code>createMemoryHistory</code>&nbsp;API，在浏览器中执行时，无法让浏览器地址栏的URL同步变化，这一点又不符合我们的用户需求，所以我们需要基于不同环境，使用不同的API。</p>
<p>具体来说，就是通过判断当前环境是浏览器客户端还是Node.js服务端，分别使用<code>createBrowserHistory</code>或<code>createMemoryHistory</code>：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">js</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-js code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">import</span> { createMemoryHistory, createBrowserHistory, <span class="hljs-title class_">Location</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'history'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">const</span> isBrowser = <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">'undefined'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="4"></span>
<span class="code-block-extension-codeLine" data-line-num="5"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> history = isBrowser</span>
<span class="code-block-extension-codeLine" data-line-num="6">  ? <span class="hljs-title function_">createBrowserHistory</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="7">  : <span class="hljs-title function_">createMemoryHistory</span>();</span>
</code></pre>
<p>修改源码后，再次执行打包编译、运行服务器应用，就没有报错了。</p>
<p>访问本地环境的URL：<a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A3000%2Fhome%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://localhost:3000/home/" ref="nofollow noopener noreferrer">http://localhost:3000/home/</a>&nbsp;，也能在Network中看到服务器直接在<code>div#root</code>中响应了组件源码渲染后的HTML：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37fa07773437456c8e9b3ec267b99de6~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp#?w=1920&amp;h=934&amp;s=85310&amp;e=webp&amp;b=2f2f2f" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>所以总结起来，CSR架构的项目改为SSR架构，主要会遇到的问题和解决方案是：</p>

















<table><thead><tr><th>问题</th><th>解决方案</th></tr></thead><tbody><tr><td>服务端打包编译配置与客户端不同步</td><td>按照报错提示，补充缺少loader、plugin等配置。</td></tr><tr><td>服务端不支持浏览器API导致的运行时报错</td><td>区分环境，用<code>const isBrowser = typeof window !== 'undefined';</code>变量判断，分别使用Node.js环境和浏览器环境的API。</td></tr></tbody></table>
<p>以上步骤完成，细看一下渲染出的页面，我们会发现页面中没有任何点击交互，甚至前端路由跳转都不生效。</p>
<p>这是因为我们还没有<strong>活化</strong>客户端。</p>
<h3 data-id="heading-12">5.&nbsp;<code>hydrate</code>活化客户端</h3>
<p>所谓活化，具体来说就是把原来调用<code>react-dom</code>的<code>render(ReactComponent, containerElement)</code>方法进行的应用初始化，改为调用<code>hydrate(ReactComponent, containerElement)</code>方法。</p>
<p>这两者的区别主要是渲染结果：</p>















<table><thead><tr><th></th><th><code>render(ReactComponent, containerElement)</code></th><th><code>hydrate(ReactComponent, containerElement)</code></th></tr></thead><tbody><tr><td>渲染结果</td><td>- 在<code>containerElement</code>容器元素内渲染出对应组件源码的HTML元素。<br>-&nbsp;<strong>同时</strong>对<code>containerElement</code>容器元素内的各个元素添加源码对应的事件处理函数。</td><td>-&nbsp;<strong>只</strong>对<code>containerElement</code>容器元素内的各个元素添加源码对应的事件处理函数。</td></tr></tbody></table>
<p>对应的代码逻辑请看示例：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">js</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-js code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">StrictMode</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-keyword">import</span> { hydrate } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BrowserRouter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="4"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">App</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="5"></span>
<span class="code-block-extension-codeLine" data-line-num="6"><span class="hljs-comment">// 把 &lt;BrowserRouter /&gt; 声明在 &lt;APP /&gt; 外层，</span></span>
<span class="code-block-extension-codeLine" data-line-num="7"><span class="hljs-comment">// 避免 serverRenderer 端执行渲染，因为没有浏览器API，导致报错</span></span>
<span class="code-block-extension-codeLine" data-line-num="8"><span class="hljs-title function_">hydrate</span>(</span>
<span class="code-block-extension-codeLine" data-line-num="9">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">StrictMode</span>&gt;</span></span></span>
<span class="code-block-extension-codeLine" data-line-num="10">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>
<span class="code-block-extension-codeLine" data-line-num="11">  <span class="hljs-tag">&lt;/<span class="hljs-name">StrictMode</span>&gt;</span>,</span>
<span class="code-block-extension-codeLine" data-line-num="12">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'root'</span>),</span>
<span class="code-block-extension-codeLine" data-line-num="13">);</span>
</code></pre>
<p>另外还有一些细节要处理。</p>
<ul>
<li>我们的JS、CSS等静态资源还没有加载，在本地环境我们用<code>express.static(DIST)</code>API来模拟一个CDN，把静态资源都部署到<code>/static</code>路径。</li>
<li>因为<code>&lt;APP /&gt;</code>内部之前遗留的<code>&nbsp;&lt;Router /&gt;</code>组件和<code>&lt;BrowserRouter /&gt;</code>功能重复、逻辑冲突，我们要将其删除。</li>
<li>还有<code>common.config.js</code>中的<code>HtmlWebpackPlugin</code>，为了避免在<code>client</code>和<code>server</code>端构建时运行2次，生成2个<code>index.html</code>模板，我们加一个<code>process.env.BUILD_SERVER</code>环境变量来控制插件动态添加到配置中。</li>
<li>最后，为了便于我们同步打包编译client和server两套代码，我们对<code>package.json</code>中的<code>scripts</code>脚本命令也要做一些整理，实现用1行命令，构建2套代码：</li>
</ul>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">json</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-json code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></span>
<span class="code-block-extension-codeLine" data-line-num="2">    <span class="hljs-attr">"build-server"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cross-env NODE_ENV=production BUILD_SERVER=true webpack --config ./webpack/server.config.js"</span><span class="hljs-punctuation">,</span></span>
<span class="code-block-extension-codeLine" data-line-num="3">    <span class="hljs-attr">"build-client"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cross-env NODE_ENV=production webpack"</span><span class="hljs-punctuation">,</span></span>
<span class="code-block-extension-codeLine" data-line-num="4">    <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npm run build-client &amp;&amp; npm run build-server"</span><span class="hljs-punctuation">,</span></span>
<span class="code-block-extension-codeLine" data-line-num="5"><span class="hljs-punctuation">}</span></span>
</code></pre>
<p>再次运行<code>npm run build</code>，就能看到先后进行了client和server两套代码的打包编译。</p>
<p>运行<code>npm run start-server</code>，访问<a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A3000%2Fregistration" target="_blank" rel="nofollow noopener noreferrer" title="http://localhost:3000/registration" ref="nofollow noopener noreferrer">http://localhost:3000/registration</a>&nbsp;、<a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A3000%2Flogin" target="_blank" rel="nofollow noopener noreferrer" title="http://localhost:3000/login" ref="nofollow noopener noreferrer">http://localhost:3000/login</a>&nbsp;等前端路由，点击、输入各类交互生效，页面也正常渲染：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ab20adc14444cfdaa29f03b5b1ab7ea~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp#?w=1920&amp;h=934&amp;s=67524&amp;e=webp&amp;b=2e2e2e" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>至此，我们将客户端渲染的CSR前端应用改为服务端渲染SSR架构的改造就完成了。</p>
<blockquote>
<p>注：以上示例较为简略，完整的SSR应用，还需要处理开发环境、用户身份校验、服务端客户端状态同步（Redux相关）等问题，做更多验证。</p>
</blockquote>
<p>但经过多年实践，开发者也逐渐地感受到了Node.js SSR服务端渲染也有许多显著痛点，主要有：</p>
<ul>
<li><strong>服务器成本高昂</strong>：相较于CSR应用，SSR应用需要更多的服务器硬件资源，更大的金钱开销。</li>
<li><strong>维护难度高：</strong> &nbsp;SSR应用需要开发者兼顾前端开发，后端开发和网络运维，对维护团队能力要求较高。</li>
</ul>
<p>以笔者的经验而言，日活跃用户千万量级的前端应用项目，SSR应用的服务器硬件开销就会达到每月上百万元，维护团队也要有处理前端、后端和服务器运维等各类问题的复合能力。</p>
<p>与此同时，Node.js服务端渲染的发展变化日新月异，社区针对这些痛点也涌现了一批优化方案，致力于改善SSR的痛点，下面我们就来进一步学习SSR的进阶优化方案。</p></div>